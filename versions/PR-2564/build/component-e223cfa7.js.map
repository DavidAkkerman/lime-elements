{"version":3,"names":["cssClasses","ANCHOR","ANIMATING_CLOSED","ANIMATING_OPEN","FIXED","IS_OPEN_BELOW","OPEN","ROOT","strings","CLOSED_EVENT","CLOSING_EVENT","OPENED_EVENT","FOCUSABLE_ELEMENTS","join","numbers","TRANSITION_OPEN_DURATION","TRANSITION_CLOSE_DURATION","MARGIN_TO_EDGE","ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO","TOUCH_EVENT_WAIT_MS","CornerBit","Corner","MDCMenuSurfaceFoundation","_super","__extends","adapter","_this","call","this","__assign","defaultAdapter","isSurfaceOpen","isQuickOpen","isHoistedElement","isFixedPosition","isHorizontallyCenteredOnViewport","maxHeight","openAnimationEndTimerId","closeAnimationEndTimerId","animationRequestId","anchorCorner","TOP_START","originCorner","anchorMargin","top","right","bottom","left","position","x","y","Object","defineProperty","get","enumerable","configurable","addClass","undefined","removeClass","hasClass","hasAnchor","isElementInContainer","isFocused","isRtl","getInnerDimensions","height","width","getAnchorDimensions","getWindowDimensions","getBodyDimensions","getWindowScroll","setPosition","setMaxHeight","setTransformOrigin","saveFocus","restoreFocus","notifyClose","notifyOpen","notifyClosing","prototype","init","_a","Error","destroy","clearTimeout","cancelAnimationFrame","setAnchorCorner","corner","flipCornerHorizontally","RIGHT","setAnchorMargin","margin","setIsHoisted","isHoisted","setFixedPosition","isFixed","setAbsolutePosition","isFinite","setIsHorizontallyCenteredOnViewport","isCentered","setQuickOpen","quickOpen","isOpen","open","dimensions","autoposition","requestAnimationFrame","setTimeout","close","skipRestoreFocus","maybeRestoreFocus","handleBodyClick","evt","el","target","handleKeydown","keyCode","key","isEscape","measurements","getAutoLayoutmeasurements","getoriginCorner","maxMenuSurfaceHeight","getMenuSurfaceMaxHeight","verticalAlignment","hasBit","BOTTOM","horizontalAlignment","horizontalOffset","getHorizontalOriginOffset","verticalOffset","getVerticalOriginOffset","_b","anchorSize","surfaceSize","adjustPositionForHoistedElement","anchorRect","bodySize","viewportSize","windowScroll","viewportDistance","isAnchoredToBottom","availableTop","availableBottom","isAvailableBottom","setBit","isFlipRtl","FLIP_RTL","hasRightBit","isAnchoredToRight","availableLeft","availableRight","isAvailableLeft","isAvailableRight","isOriginCornerAlignedToEnd","unsetBit","isBottomAligned","isBottomAnchored","isRightAligned","avoidHorizontalOverlap","rightOffset","avoidVerticalOverlap","e_1","props","keys","props_1","__values","props_1_1","next","done","prop","value","e_1_1","error","return","isRootFocused","childHasFocus","document","activeElement","bit","Boolean","num","MDCFoundation","MDCMenuSurface","apply","arguments","attachTo","root","initialSyncWithDOM","parentEl","parentElement","anchorElement","classList","contains","event","foundation","registerBodyClickListener","body","addEventListener","capture","deregisterBodyClickListener","removeEventListener","listen","unlisten","set","setMenuSurfaceAnchorElement","element","add","remove","getDefaultFoundation","className","emit","getComputedStyle","getPropertyValue","origin","propertyName","getCorrectPropertyName","window","style","setProperty","previousFocus","focus","offsetWidth","offsetHeight","getBoundingClientRect","innerWidth","innerHeight","clientWidth","clientHeight","pageXOffset","pageYOffset","rootHTML","MDCComponent"],"sources":["./node_modules/@material/menu-surface/constants.js","./node_modules/@material/menu-surface/foundation.js","./node_modules/@material/menu-surface/component.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nvar cssClasses = {\n    ANCHOR: 'mdc-menu-surface--anchor',\n    ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',\n    ANIMATING_OPEN: 'mdc-menu-surface--animating-open',\n    FIXED: 'mdc-menu-surface--fixed',\n    IS_OPEN_BELOW: 'mdc-menu-surface--is-open-below',\n    OPEN: 'mdc-menu-surface--open',\n    ROOT: 'mdc-menu-surface',\n};\n// tslint:disable:object-literal-sort-keys\nvar strings = {\n    CLOSED_EVENT: 'MDCMenuSurface:closed',\n    CLOSING_EVENT: 'MDCMenuSurface:closing',\n    OPENED_EVENT: 'MDCMenuSurface:opened',\n    FOCUSABLE_ELEMENTS: [\n        'button:not(:disabled)',\n        '[href]:not([aria-disabled=\"true\"])',\n        'input:not(:disabled)',\n        'select:not(:disabled)',\n        'textarea:not(:disabled)',\n        '[tabindex]:not([tabindex=\"-1\"]):not([aria-disabled=\"true\"])',\n    ].join(', '),\n};\n// tslint:enable:object-literal-sort-keys\nvar numbers = {\n    /** Total duration of menu-surface open animation. */\n    TRANSITION_OPEN_DURATION: 120,\n    /** Total duration of menu-surface close animation. */\n    TRANSITION_CLOSE_DURATION: 75,\n    /**\n     * Margin left to the edge of the viewport when menu-surface is at maximum\n     * possible height. Also used as a viewport margin.\n     */\n    MARGIN_TO_EDGE: 32,\n    /**\n     * Ratio of anchor width to menu-surface width for switching from corner\n     * positioning to center positioning.\n     */\n    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,\n    /**\n     * Amount of time to wait before restoring focus when closing the menu\n     * surface. This is important because if a touch event triggered the menu\n     * close, and the subsequent mouse event occurs after focus is restored, then\n     * the restored focus would be lost.\n     */\n    TOUCH_EVENT_WAIT_MS: 30,\n};\n/**\n * Enum for bits in the {@see Corner) bitmap.\n */\nvar CornerBit;\n(function (CornerBit) {\n    CornerBit[CornerBit[\"BOTTOM\"] = 1] = \"BOTTOM\";\n    CornerBit[CornerBit[\"CENTER\"] = 2] = \"CENTER\";\n    CornerBit[CornerBit[\"RIGHT\"] = 4] = \"RIGHT\";\n    CornerBit[CornerBit[\"FLIP_RTL\"] = 8] = \"FLIP_RTL\";\n})(CornerBit || (CornerBit = {}));\n/**\n * Enum for representing an element corner for positioning the menu-surface.\n *\n * The START constants map to LEFT if element directionality is left\n * to right and RIGHT if the directionality is right to left.\n * Likewise END maps to RIGHT or LEFT depending on the directionality.\n */\nvar Corner;\n(function (Corner) {\n    Corner[Corner[\"TOP_LEFT\"] = 0] = \"TOP_LEFT\";\n    Corner[Corner[\"TOP_RIGHT\"] = 4] = \"TOP_RIGHT\";\n    Corner[Corner[\"BOTTOM_LEFT\"] = 1] = \"BOTTOM_LEFT\";\n    Corner[Corner[\"BOTTOM_RIGHT\"] = 5] = \"BOTTOM_RIGHT\";\n    Corner[Corner[\"TOP_START\"] = 8] = \"TOP_START\";\n    Corner[Corner[\"TOP_END\"] = 12] = \"TOP_END\";\n    Corner[Corner[\"BOTTOM_START\"] = 9] = \"BOTTOM_START\";\n    Corner[Corner[\"BOTTOM_END\"] = 13] = \"BOTTOM_END\";\n})(Corner || (Corner = {}));\nexport { cssClasses, strings, numbers, CornerBit, Corner };\n//# sourceMappingURL=constants.js.map","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends, __values } from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { Corner, CornerBit, cssClasses, numbers, strings } from './constants';\nvar MDCMenuSurfaceFoundation = /** @class */ (function (_super) {\n    __extends(MDCMenuSurfaceFoundation, _super);\n    function MDCMenuSurfaceFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation.defaultAdapter), adapter)) || this;\n        _this.isSurfaceOpen = false;\n        _this.isQuickOpen = false;\n        _this.isHoistedElement = false;\n        _this.isFixedPosition = false;\n        _this.isHorizontallyCenteredOnViewport = false;\n        _this.maxHeight = 0;\n        _this.openAnimationEndTimerId = 0;\n        _this.closeAnimationEndTimerId = 0;\n        _this.animationRequestId = 0;\n        _this.anchorCorner = Corner.TOP_START;\n        /**\n         * Corner of the menu surface to which menu surface is attached to anchor.\n         *\n         *  Anchor corner --->+----------+\n         *                    |  ANCHOR  |\n         *                    +----------+\n         *  Origin corner --->+--------------+\n         *                    |              |\n         *                    |              |\n         *                    | MENU SURFACE |\n         *                    |              |\n         *                    |              |\n         *                    +--------------+\n         */\n        _this.originCorner = Corner.TOP_START;\n        _this.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 };\n        _this.position = { x: 0, y: 0 };\n        return _this;\n    }\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"cssClasses\", {\n        get: function () {\n            return cssClasses;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"strings\", {\n        get: function () {\n            return strings;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"numbers\", {\n        get: function () {\n            return numbers;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"Corner\", {\n        get: function () {\n            return Corner;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"defaultAdapter\", {\n        /**\n         * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.\n         */\n        get: function () {\n            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n            return {\n                addClass: function () { return undefined; },\n                removeClass: function () { return undefined; },\n                hasClass: function () { return false; },\n                hasAnchor: function () { return false; },\n                isElementInContainer: function () { return false; },\n                isFocused: function () { return false; },\n                isRtl: function () { return false; },\n                getInnerDimensions: function () { return ({ height: 0, width: 0 }); },\n                getAnchorDimensions: function () { return null; },\n                getWindowDimensions: function () { return ({ height: 0, width: 0 }); },\n                getBodyDimensions: function () { return ({ height: 0, width: 0 }); },\n                getWindowScroll: function () { return ({ x: 0, y: 0 }); },\n                setPosition: function () { return undefined; },\n                setMaxHeight: function () { return undefined; },\n                setTransformOrigin: function () { return undefined; },\n                saveFocus: function () { return undefined; },\n                restoreFocus: function () { return undefined; },\n                notifyClose: function () { return undefined; },\n                notifyOpen: function () { return undefined; },\n                notifyClosing: function () { return undefined; },\n            };\n            // tslint:enable:object-literal-sort-keys\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MDCMenuSurfaceFoundation.prototype.init = function () {\n        var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;\n        if (!this.adapter.hasClass(ROOT)) {\n            throw new Error(ROOT + \" class required in root element.\");\n        }\n        if (this.adapter.hasClass(OPEN)) {\n            this.isSurfaceOpen = true;\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.destroy = function () {\n        clearTimeout(this.openAnimationEndTimerId);\n        clearTimeout(this.closeAnimationEndTimerId);\n        // Cancel any currently running animations.\n        cancelAnimationFrame(this.animationRequestId);\n    };\n    /**\n     * @param corner Default anchor corner alignment of top-left menu surface\n     *     corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {\n        this.anchorCorner = corner;\n    };\n    /**\n     * Flip menu corner horizontally.\n     */\n    MDCMenuSurfaceFoundation.prototype.flipCornerHorizontally = function () {\n        this.originCorner = this.originCorner ^ CornerBit.RIGHT;\n    };\n    /**\n     * @param margin Set of margin values from anchor.\n     */\n    MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {\n        this.anchorMargin.top = margin.top || 0;\n        this.anchorMargin.right = margin.right || 0;\n        this.anchorMargin.bottom = margin.bottom || 0;\n        this.anchorMargin.left = margin.left || 0;\n    };\n    /** Used to indicate if the menu-surface is hoisted to the body. */\n    MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {\n        this.isHoistedElement = isHoisted;\n    };\n    /**\n     * Used to set the menu-surface calculations based on a fixed position menu.\n     */\n    MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {\n        this.isFixedPosition = isFixedPosition;\n    };\n    /**\n     * @return Returns true if menu is in fixed (`position: fixed`) position.\n     */\n    MDCMenuSurfaceFoundation.prototype.isFixed = function () {\n        return this.isFixedPosition;\n    };\n    /** Sets the menu-surface position on the page. */\n    MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {\n        this.position.x = this.isFinite(x) ? x : 0;\n        this.position.y = this.isFinite(y) ? y : 0;\n    };\n    /** Sets whether menu-surface should be horizontally centered to viewport. */\n    MDCMenuSurfaceFoundation.prototype.setIsHorizontallyCenteredOnViewport = function (isCentered) {\n        this.isHorizontallyCenteredOnViewport = isCentered;\n    };\n    MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {\n        this.isQuickOpen = quickOpen;\n    };\n    /**\n     * Sets maximum menu-surface height on open.\n     * @param maxHeight The desired max-height. Set to 0 (default) to\n     *     automatically calculate max height based on available viewport space.\n     */\n    MDCMenuSurfaceFoundation.prototype.setMaxHeight = function (maxHeight) {\n        this.maxHeight = maxHeight;\n    };\n    MDCMenuSurfaceFoundation.prototype.isOpen = function () {\n        return this.isSurfaceOpen;\n    };\n    /**\n     * Open the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.open = function () {\n        var _this = this;\n        if (this.isSurfaceOpen) {\n            return;\n        }\n        this.adapter.saveFocus();\n        if (this.isQuickOpen) {\n            this.isSurfaceOpen = true;\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            this.dimensions = this.adapter.getInnerDimensions();\n            this.autoposition();\n            this.adapter.notifyOpen();\n        }\n        else {\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n            this.animationRequestId = requestAnimationFrame(function () {\n                _this.dimensions = _this.adapter.getInnerDimensions();\n                _this.autoposition();\n                _this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n                _this.openAnimationEndTimerId = setTimeout(function () {\n                    _this.openAnimationEndTimerId = 0;\n                    _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n                    _this.adapter.notifyOpen();\n                }, numbers.TRANSITION_OPEN_DURATION);\n            });\n            this.isSurfaceOpen = true;\n        }\n    };\n    /**\n     * Closes the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {\n        var _this = this;\n        if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }\n        if (!this.isSurfaceOpen) {\n            return;\n        }\n        this.adapter.notifyClosing();\n        if (this.isQuickOpen) {\n            this.isSurfaceOpen = false;\n            if (!skipRestoreFocus) {\n                this.maybeRestoreFocus();\n            }\n            this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n            this.adapter.notifyClose();\n            return;\n        }\n        this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n        requestAnimationFrame(function () {\n            _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n            _this.closeAnimationEndTimerId = setTimeout(function () {\n                _this.closeAnimationEndTimerId = 0;\n                _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n                _this.adapter.notifyClose();\n            }, numbers.TRANSITION_CLOSE_DURATION);\n        });\n        this.isSurfaceOpen = false;\n        if (!skipRestoreFocus) {\n            this.maybeRestoreFocus();\n        }\n    };\n    /** Handle clicks and close if not within menu-surface element. */\n    MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {\n        var el = evt.target;\n        if (this.adapter.isElementInContainer(el)) {\n            return;\n        }\n        this.close();\n    };\n    /** Handle keys that close the surface. */\n    MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {\n        var keyCode = evt.keyCode, key = evt.key;\n        var isEscape = key === 'Escape' || keyCode === 27;\n        if (isEscape) {\n            this.close();\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.autoposition = function () {\n        var _a;\n        // Compute measurements for autoposition methods reuse.\n        this.measurements = this.getAutoLayoutmeasurements();\n        var corner = this.getoriginCorner();\n        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);\n        var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n        var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';\n        var horizontalOffset = this.getHorizontalOriginOffset(corner);\n        var verticalOffset = this.getVerticalOriginOffset(corner);\n        var _b = this.measurements, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;\n        var position = (_a = {},\n            _a[horizontalAlignment] = horizontalOffset,\n            _a[verticalAlignment] = verticalOffset,\n            _a);\n        // Center align when anchor width is comparable or greater than menu\n        // surface, otherwise keep corner.\n        if (anchorSize.width / surfaceSize.width >\n            numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n            horizontalAlignment = 'center';\n        }\n        // If the menu-surface has been hoisted to the body, it's no longer relative\n        // to the anchor element\n        if (this.isHoistedElement || this.isFixedPosition) {\n            this.adjustPositionForHoistedElement(position);\n        }\n        this.adapter.setTransformOrigin(horizontalAlignment + \" \" + verticalAlignment);\n        this.adapter.setPosition(position);\n        this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\n        // If it is opened from the top then add is-open-below class\n        if (!this.hasBit(corner, CornerBit.BOTTOM)) {\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n        }\n    };\n    /**\n     * @return Measurements used to position menu surface popup.\n     */\n    MDCMenuSurfaceFoundation.prototype.getAutoLayoutmeasurements = function () {\n        var anchorRect = this.adapter.getAnchorDimensions();\n        var bodySize = this.adapter.getBodyDimensions();\n        var viewportSize = this.adapter.getWindowDimensions();\n        var windowScroll = this.adapter.getWindowScroll();\n        if (!anchorRect) {\n            // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n            anchorRect = {\n                top: this.position.y,\n                right: this.position.x,\n                bottom: this.position.y,\n                left: this.position.x,\n                width: 0,\n                height: 0,\n            };\n            // tslint:enable:object-literal-sort-keys\n        }\n        return {\n            anchorSize: anchorRect,\n            bodySize: bodySize,\n            surfaceSize: this.dimensions,\n            viewportDistance: {\n                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n                top: anchorRect.top,\n                right: viewportSize.width - anchorRect.right,\n                bottom: viewportSize.height - anchorRect.bottom,\n                left: anchorRect.left,\n                // tslint:enable:object-literal-sort-keys\n            },\n            viewportSize: viewportSize,\n            windowScroll: windowScroll,\n        };\n    };\n    /**\n     * Computes the corner of the anchor from which to animate and position the\n     * menu surface.\n     *\n     * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL\n     * context. E.g., menu surface will be positioned from right side on TOP_END.\n     */\n    MDCMenuSurfaceFoundation.prototype.getoriginCorner = function () {\n        var corner = this.originCorner;\n        var _a = this.measurements, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;\n        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;\n        var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n        var availableTop;\n        var availableBottom;\n        if (isAnchoredToBottom) {\n            availableTop =\n                viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;\n            availableBottom =\n                viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;\n        }\n        else {\n            availableTop =\n                viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;\n            availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE +\n                anchorSize.height - this.anchorMargin.top;\n        }\n        var isAvailableBottom = availableBottom - surfaceSize.height > 0;\n        if (!isAvailableBottom && availableTop > availableBottom) {\n            // Attach bottom side of surface to the anchor.\n            corner = this.setBit(corner, CornerBit.BOTTOM);\n        }\n        var isRtl = this.adapter.isRtl();\n        var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);\n        var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) ||\n            this.hasBit(corner, CornerBit.RIGHT);\n        // Whether surface attached to right side of anchor element.\n        var isAnchoredToRight = false;\n        // Anchored to start\n        if (isRtl && isFlipRtl) {\n            isAnchoredToRight = !hasRightBit;\n        }\n        else {\n            // Anchored to right\n            isAnchoredToRight = hasRightBit;\n        }\n        var availableLeft;\n        var availableRight;\n        if (isAnchoredToRight) {\n            availableLeft =\n                viewportDistance.left + anchorSize.width + this.anchorMargin.right;\n            availableRight = viewportDistance.right - this.anchorMargin.right;\n        }\n        else {\n            availableLeft = viewportDistance.left + this.anchorMargin.left;\n            availableRight =\n                viewportDistance.right + anchorSize.width - this.anchorMargin.left;\n        }\n        var isAvailableLeft = availableLeft - surfaceSize.width > 0;\n        var isAvailableRight = availableRight - surfaceSize.width > 0;\n        var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) &&\n            this.hasBit(corner, CornerBit.RIGHT);\n        if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl ||\n            !isAvailableLeft && isOriginCornerAlignedToEnd) {\n            // Attach left side of surface to the anchor.\n            corner = this.unsetBit(corner, CornerBit.RIGHT);\n        }\n        else if (isAvailableLeft && isAnchoredToRight && isRtl ||\n            (isAvailableLeft && !isAnchoredToRight && hasRightBit) ||\n            (!isAvailableRight && availableLeft >= availableRight)) {\n            // Attach right side of surface to the anchor.\n            corner = this.setBit(corner, CornerBit.RIGHT);\n        }\n        return corner;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Maximum height of the menu surface, based on available space. 0\n     *     indicates should not be set.\n     */\n    MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight = function (corner) {\n        if (this.maxHeight > 0) {\n            return this.maxHeight;\n        }\n        var viewportDistance = this.measurements.viewportDistance;\n        var maxHeight = 0;\n        var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n        var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;\n        // When maximum height is not specified, it is handled from CSS.\n        if (isBottomAligned) {\n            maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;\n            if (!isBottomAnchored) {\n                maxHeight += this.measurements.anchorSize.height;\n            }\n        }\n        else {\n            maxHeight = viewportDistance.bottom - this.anchorMargin.bottom +\n                this.measurements.anchorSize.height - MARGIN_TO_EDGE;\n            if (isBottomAnchored) {\n                maxHeight -= this.measurements.anchorSize.height;\n            }\n        }\n        return maxHeight;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Horizontal offset of menu surface origin corner from corresponding\n     *     anchor corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset = function (corner) {\n        var anchorSize = this.measurements.anchorSize;\n        // isRightAligned corresponds to using the 'right' property on the surface.\n        var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);\n        var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);\n        if (isRightAligned) {\n            var rightOffset = avoidHorizontalOverlap ?\n                anchorSize.width - this.anchorMargin.left :\n                this.anchorMargin.right;\n            // For hoisted or fixed elements, adjust the offset by the difference\n            // between viewport width and body width so when we calculate the right\n            // value (`adjustPositionForHoistedElement`) based on the element\n            // position, the right property is correct.\n            if (this.isHoistedElement || this.isFixedPosition) {\n                return rightOffset -\n                    (this.measurements.viewportSize.width -\n                        this.measurements.bodySize.width);\n            }\n            return rightOffset;\n        }\n        return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right :\n            this.anchorMargin.left;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Vertical offset of menu surface origin corner from corresponding\n     *     anchor corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset = function (corner) {\n        var anchorSize = this.measurements.anchorSize;\n        var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n        var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n        var y = 0;\n        if (isBottomAligned) {\n            y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top :\n                -this.anchorMargin.bottom;\n        }\n        else {\n            y = avoidVerticalOverlap ?\n                (anchorSize.height + this.anchorMargin.bottom) :\n                this.anchorMargin.top;\n        }\n        return y;\n    };\n    /**\n     * Calculates the offsets for positioning the menu-surface when the\n     * menu-surface has been hoisted to the body.\n     */\n    MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement = function (position) {\n        var e_1, _a;\n        var _b = this.measurements, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance, surfaceSize = _b.surfaceSize, viewportSize = _b.viewportSize;\n        var props = Object.keys(position);\n        try {\n            for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n                var prop = props_1_1.value;\n                var value = position[prop] || 0;\n                if (this.isHorizontallyCenteredOnViewport &&\n                    (prop === 'left' || prop === 'right')) {\n                    position[prop] = (viewportSize.width - surfaceSize.width) / 2;\n                    continue;\n                }\n                // Hoisted surfaces need to have the anchor elements location on the page\n                // added to the position properties for proper alignment on the body.\n                value += viewportDistance[prop];\n                // Surfaces that are absolutely positioned need to have additional\n                // calculations for scroll and bottom positioning.\n                if (!this.isFixedPosition) {\n                    if (prop === 'top') {\n                        value += windowScroll.y;\n                    }\n                    else if (prop === 'bottom') {\n                        value -= windowScroll.y;\n                    }\n                    else if (prop === 'left') {\n                        value += windowScroll.x;\n                    }\n                    else { // prop === 'right'\n                        value -= windowScroll.x;\n                    }\n                }\n                position[prop] = value;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * The last focused element when the menu surface was opened should regain\n     * focus, if the user is focused on or within the menu surface when it is\n     * closed.\n     */\n    MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus = function () {\n        var _this = this;\n        var isRootFocused = this.adapter.isFocused();\n        var childHasFocus = document.activeElement &&\n            this.adapter.isElementInContainer(document.activeElement);\n        if (isRootFocused || childHasFocus) {\n            // Wait before restoring focus when closing the menu surface. This is\n            // important because if a touch event triggered the menu close, and the\n            // subsequent mouse event occurs after focus is restored, then the\n            // restored focus would be lost.\n            setTimeout(function () {\n                _this.adapter.restoreFocus();\n            }, numbers.TOUCH_EVENT_WAIT_MS);\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.hasBit = function (corner, bit) {\n        return Boolean(corner & bit); // tslint:disable-line:no-bitwise\n    };\n    MDCMenuSurfaceFoundation.prototype.setBit = function (corner, bit) {\n        return corner | bit; // tslint:disable-line:no-bitwise\n    };\n    MDCMenuSurfaceFoundation.prototype.unsetBit = function (corner, bit) {\n        return corner ^ bit;\n    };\n    /**\n     * isFinite that doesn't force conversion to number type.\n     * Equivalent to Number.isFinite in ES2015, which is not supported in IE.\n     */\n    MDCMenuSurfaceFoundation.prototype.isFinite = function (num) {\n        return typeof num === 'number' && isFinite(num);\n    };\n    return MDCMenuSurfaceFoundation;\n}(MDCFoundation));\nexport { MDCMenuSurfaceFoundation };\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nexport default MDCMenuSurfaceFoundation;\n//# sourceMappingURL=foundation.js.map","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __extends } from \"tslib\";\nimport { MDCComponent } from '@material/base/component';\nimport { cssClasses, strings } from './constants';\nimport { MDCMenuSurfaceFoundation } from './foundation';\nimport { getCorrectPropertyName } from '@material/animation/util';\nvar MDCMenuSurface = /** @class */ (function (_super) {\n    __extends(MDCMenuSurface, _super);\n    function MDCMenuSurface() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MDCMenuSurface.attachTo = function (root) {\n        return new MDCMenuSurface(root);\n    };\n    MDCMenuSurface.prototype.initialSyncWithDOM = function () {\n        var _this = this;\n        var parentEl = this.root.parentElement;\n        this.anchorElement = parentEl && parentEl.classList.contains(cssClasses.ANCHOR) ? parentEl : null;\n        if (this.root.classList.contains(cssClasses.FIXED)) {\n            this.setFixedPosition(true);\n        }\n        this.handleKeydown = function (event) {\n            _this.foundation.handleKeydown(event);\n        };\n        this.handleBodyClick = function (event) {\n            _this.foundation.handleBodyClick(event);\n        };\n        // capture so that no race between handleBodyClick and quickOpen when\n        // menusurface opened on button click which registers this listener\n        this.registerBodyClickListener = function () {\n            document.body.addEventListener('click', _this.handleBodyClick, { capture: true });\n        };\n        this.deregisterBodyClickListener = function () {\n            document.body.removeEventListener('click', _this.handleBodyClick, { capture: true });\n        };\n        this.listen('keydown', this.handleKeydown);\n        this.listen(strings.OPENED_EVENT, this.registerBodyClickListener);\n        this.listen(strings.CLOSED_EVENT, this.deregisterBodyClickListener);\n    };\n    MDCMenuSurface.prototype.destroy = function () {\n        this.unlisten('keydown', this.handleKeydown);\n        this.unlisten(strings.OPENED_EVENT, this.registerBodyClickListener);\n        this.unlisten(strings.CLOSED_EVENT, this.deregisterBodyClickListener);\n        _super.prototype.destroy.call(this);\n    };\n    MDCMenuSurface.prototype.isOpen = function () {\n        return this.foundation.isOpen();\n    };\n    MDCMenuSurface.prototype.open = function () {\n        this.foundation.open();\n    };\n    MDCMenuSurface.prototype.close = function (skipRestoreFocus) {\n        if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }\n        this.foundation.close(skipRestoreFocus);\n    };\n    Object.defineProperty(MDCMenuSurface.prototype, \"quickOpen\", {\n        set: function (quickOpen) {\n            this.foundation.setQuickOpen(quickOpen);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** Sets the foundation to use page offsets for an positioning when the menu is hoisted to the body. */\n    MDCMenuSurface.prototype.setIsHoisted = function (isHoisted) {\n        this.foundation.setIsHoisted(isHoisted);\n    };\n    /** Sets the element that the menu-surface is anchored to. */\n    MDCMenuSurface.prototype.setMenuSurfaceAnchorElement = function (element) {\n        this.anchorElement = element;\n    };\n    /** Sets the menu-surface to position: fixed. */\n    MDCMenuSurface.prototype.setFixedPosition = function (isFixed) {\n        if (isFixed) {\n            this.root.classList.add(cssClasses.FIXED);\n        }\n        else {\n            this.root.classList.remove(cssClasses.FIXED);\n        }\n        this.foundation.setFixedPosition(isFixed);\n    };\n    /** Sets the absolute x/y position to position based on. Requires the menu to be hoisted. */\n    MDCMenuSurface.prototype.setAbsolutePosition = function (x, y) {\n        this.foundation.setAbsolutePosition(x, y);\n        this.setIsHoisted(true);\n    };\n    /**\n     * @param corner Default anchor corner alignment of top-left surface corner.\n     */\n    MDCMenuSurface.prototype.setAnchorCorner = function (corner) {\n        this.foundation.setAnchorCorner(corner);\n    };\n    MDCMenuSurface.prototype.setAnchorMargin = function (margin) {\n        this.foundation.setAnchorMargin(margin);\n    };\n    MDCMenuSurface.prototype.getDefaultFoundation = function () {\n        var _this = this;\n        // DO NOT INLINE this variable. For backward compatibility, foundations take a Partial<MDCFooAdapter>.\n        // To ensure we don't accidentally omit any methods, we need a separate, strongly typed adapter variable.\n        // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n        var adapter = {\n            addClass: function (className) { return _this.root.classList.add(className); },\n            removeClass: function (className) { return _this.root.classList.remove(className); },\n            hasClass: function (className) { return _this.root.classList.contains(className); },\n            hasAnchor: function () { return !!_this.anchorElement; },\n            notifyClose: function () {\n                return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});\n            },\n            notifyClosing: function () {\n                _this.emit(MDCMenuSurfaceFoundation.strings.CLOSING_EVENT, {});\n            },\n            notifyOpen: function () {\n                return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});\n            },\n            isElementInContainer: function (el) { return _this.root.contains(el); },\n            isRtl: function () {\n                return getComputedStyle(_this.root).getPropertyValue('direction') === 'rtl';\n            },\n            setTransformOrigin: function (origin) {\n                var propertyName = getCorrectPropertyName(window, 'transform') + \"-origin\";\n                _this.root.style.setProperty(propertyName, origin);\n            },\n            isFocused: function () { return document.activeElement === _this.root; },\n            saveFocus: function () {\n                _this.previousFocus =\n                    document.activeElement;\n            },\n            restoreFocus: function () {\n                if (_this.root.contains(document.activeElement)) {\n                    if (_this.previousFocus && _this.previousFocus.focus) {\n                        _this.previousFocus.focus();\n                    }\n                }\n            },\n            getInnerDimensions: function () {\n                return {\n                    width: _this.root.offsetWidth,\n                    height: _this.root.offsetHeight\n                };\n            },\n            getAnchorDimensions: function () { return _this.anchorElement ?\n                _this.anchorElement.getBoundingClientRect() :\n                null; },\n            getWindowDimensions: function () {\n                return { width: window.innerWidth, height: window.innerHeight };\n            },\n            getBodyDimensions: function () {\n                return { width: document.body.clientWidth, height: document.body.clientHeight };\n            },\n            getWindowScroll: function () {\n                return { x: window.pageXOffset, y: window.pageYOffset };\n            },\n            setPosition: function (position) {\n                var rootHTML = _this.root;\n                rootHTML.style.left = 'left' in position ? position.left + \"px\" : '';\n                rootHTML.style.right = 'right' in position ? position.right + \"px\" : '';\n                rootHTML.style.top = 'top' in position ? position.top + \"px\" : '';\n                rootHTML.style.bottom =\n                    'bottom' in position ? position.bottom + \"px\" : '';\n            },\n            setMaxHeight: function (height) {\n                _this.root.style.maxHeight = height;\n            },\n        };\n        // tslint:enable:object-literal-sort-keys\n        return new MDCMenuSurfaceFoundation(adapter);\n    };\n    return MDCMenuSurface;\n}(MDCComponent));\nexport { MDCMenuSurface };\n//# sourceMappingURL=component.js.map"],"mappings":"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"}